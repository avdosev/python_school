# Brainfuck
## О языке
Brainfuck — один из известнейших эзотерических языков программирования, придуман Урбаном Мюллером (нем. Urban Müller) в 1993 году, 
известен своим минимализмом. 
Название языка можно перевести на русский как вынос мозга, оно напрямую образовано от английского выражения brainfuck. 
Язык имеет восемь команд, каждая из которых записывается одним символом. Исходный код программы на Brainfuck представляет собой последовательность этих символов без какого-либо дополнительного синтаксиса.

Одним из мотивов Урбана Мюллера было создание языка с как можно меньшим интерпритатором / компилятором . Отчасти он был вдохновлён языком FALSE, для которого существовал компилятор размером 1024 байта. Существуют компиляторы языка Brainfuck размером меньше 200 байт. Программы на языке Brainfuck писать сложно, за что его иногда называют языком для мазохистов. 
Но при этом важно отметить, что Brainfuck является вполне естественным, полным и простым языком и может использоваться при определении понятия вычислимости.

Машина, которой управляют команды Brainfuck, состоит из упорядоченного набора ячеек и указателя текущей ячейки, напоминая ленту и головку машины Тьюринга. Кроме того, подразумевается устройство общения с внешним миром (см. команды . и ,) через поток ввода и поток вывода.



Команда Brainfuck |	Эквивалент на Python | Описание команды |
------------------|------------------|------------------|
Начало программы  |	i = 0 | выделяется память под 30 000 ячеек с нулевыми  начальными значениями
\> | i += 1 | перейти к следующей ячейке
\< | i -= 1 | перейти к предыдущей ячейке
\+ | tier[i] = (tier[i] + 1) & 0xFF | увеличить значение в текущей ячейке на 1 при этом оставив в диапазоне от 0 до 255
\- | tier[i] = max(tier[i] - 1, 0) | уменьшить значение в текущей ячейке на 1 при этом оставив в диапазоне от 0 до 255
\. | putchar(tier[i]); | напечатать значение из текущей ячейки
\, | tier[i] = getchar(); | ввести извне значение и сохранить в текущей ячейке
\[ | while tier[i] == 0: | если значение текущей ячейки ноль, перейти вперёд по тексту программы на ячейку, следующую за соответствующей ] (с учётом вложенности)
\] | конец блока `while` | если значение текущей ячейки не нуль, перейти назад по тексту программы на символ [ (с учётом вложенности)

## Пример программы
Программа на языке Brainfuck, печатающая «Hello World!»:
```
++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++
.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.
------.--------.>+.>.
```
Разбор программы:

Подготовка в памяти (с ячейки 1) массива значений, близких к ASCII-кодам символов, которые необходимо вывести (70, 100, 30, 10), через повторение 10 раз приращения ячеек на 7, 10, 3 и 1, соответственно

Код | Пояснение
----|----------
++++++++++ | присваивание ячейке 0 (счетчику) значения 10
[ | повторять, пока значение текущей ячейки (ячейки 0) больше нуля
\>+++++++ | приращение ячейки 1 на 7
\>++++++++++ | приращение ячейки 2 на 10
\>+++ | приращение ячейки 3 на 3
\>+ | приращение ячейки 4 на 1
\<<<<- | возврат к ячейке 0 (счетчику), и его уменьшение на 1
\] | вернуться к началу цикла

Получение кодов букв и их вывод

Код | Пояснение
----|----------
\>++. | Вывод «Н». Получение кода «H» (72) из 70 в ячейке 1 и вывод
\>+. | Вывод «e». Получение кода «e» (101) из 100 в ячейке 2 и вывод
\+++++++.. | Вывод «ll». Получение кода «l» (108) из 101 в ячейке 2 и вывод дважды
\+++. | Вывод «o». Получение кода «o» (111) из 108 в ячейке 2 и вывод
\>++. | Вывод пробела. Получение кода пробела (32) из 30 в ячейке 3 и вывод
<<+++++++++++++++. | Вывод «W». Получение кода «W» (87) из 72 в ячейке 1 и вывод
\>. | Вывод «o». Код «o» (111) уже находится в ячейке 2, просто его выводим
\+++. | Вывод «r». Получение кода «r» (114) из 111 в ячейке 2 и вывод
\------. | Вывод «l». Получение кода «l» (108) из 114 в ячейке 2 и вывод
\--------. | Вывод «d». Получение кода «d» (100) из 108 в ячейке 2 и вывод
\>+. | Вывод «!». Получение кода «!» (33) из 32 в ячейке 3 и вывод
\>. | Вывод кода перевода строки (10) из ячейки 4

В принципе, печать «Hello World!» можно реализовать проще, но программа будет в три с лишним раза больше, чем приведённый выше оптимизированный вариант:

~~~
+++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++.+++++++++++++++++
++++++++++++.+++++++..+++.-------------------
---------------------------------------------
---------------.+++++++++++++++++++++++++++++
++++++++++++++++++++++++++.++++++++++++++++++
++++++.+++.------.--------.------------------
---------------------------------------------
----.-----------------------.
~~~

## Интерпретатор Brainfuck

Далее будет представлен процесс создания интерпитатора Brainfuck

Начнем с иницализации
~~~Python
tier = [0]*30000 # Массив заполненный нулями размером в 30 тысяч "ячеек", символизирует ленту
i = 0 # начальная позиция в ленте
~~~

Так как код нужно откуда-то брать, то пускай это будет классический input
~~~Python
code = input()
~~~

Цикл интерпритации нашей программы
~~~Python
j = 0
cycle_counter = 0
while j < len(code): 
    token = code[j]
                
    # Далее тут будет кусок код интерпритирующий каждый токен
    # Токен в нашем случае это просто символ в строке

    j += 1
~~~

Собственно кусок кода отвечающий за интерпритацию каждого токена. Это самый проблемный кусок, тк по сути в нем заключена вся логика языка и если допустить ошибку то и язык будет другим.

~~~Python
    if token == '>': # Будем работать с правой ячейкой
        i += 1
    elif token == '<': # Будем работать с левой ячейкой 
        i -= 1
    elif token == '+': # Увеличиваем значение текщей ячейки 
        tier[i] = (tier[i] + 1) & 0xFF # константа необходимая для ограничения значений наших ячеек
        # Аналог этого кода
        # tier[i] = (tier[i] + 1) % 256
    elif token == '-': # уменьшаем значение текущей ячейки
        tier[i] = max(tier[i] - 1, 0)
    elif token == ',': # считываем один символ
        tier[i] = ord(input()[0])
    elif token == '.': # выводим один символ
        print(chr(tier[i]), end='', sep='')
~~~

Ок на этом этапе наш интепритатор может работать с простыми программами.
Можно например попробовать запустить тестовый `Hello world`

~~~
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.+++++++++++++++++++++++++++++.+++++++..+++.-------------------------------------------------------------------------------.+++++++++++++++++++++++++++++++++++++++++++++++++++++++.++++++++++++++++++++++++.+++.------.--------.-------------------------------------------------------------------.-----------------------.
~~~

Далее самое сложно - циклы. С ними язык становится богаче и универсальнее.

~~~Python
    elif token == '[': # Встретили начало цикла
        # Если текущая ячейка не равна нулю то делать ничего не надо и продолжаем интерпритировать
        if tier[i] == 0: # Нужно пропустить тело цикла
            cycle_counter += 1
            while cycle_counter > 0:
                token = code[j+1]
                if token == ']':
                    cycle_counter -= 1
                if token == '[':
                    cycle_counter += 1
                j += 1
    elif token == ']': # Встретили конец цикла
        # Если текущая ячейка равна нулю то цикл дальше не будет работать и мы можем просто продолжить выполнять
        if tier[i] != 0: # Нужно вернуться в начало цикла
            cycle_counter += 1
            while cycle_counter > 0:
                j -= 1
                token = code[j]
                if token == ']':
                    cycle_counter += 1
                if token == '[':
                    cycle_counter -= 1
~~~

Отлично, теперь язык готов к использованию в продакшене.