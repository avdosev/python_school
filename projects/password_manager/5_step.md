# Безопасность и авторизация
На данный момент предполагается что у вас уже есть класс бд для юзеров, минимального функционала будет достаточно

1. [Безопасность](#security)
1. [Авторизация](#auth)

## Security

Когда встал вопрос хранения паролей, конечно, первой идеей возникает просто записывать их в открытом виде в соответствующей табличке в базе данных. И все бы ничего, если бы доступ к ней действительно напрямую клиенты получить не могли. Но, к сожалению, в различных веб-приложениях по-прежнему иногда работает известная всем SQL-инъекция, не говоря уже о других потенциальных уязвимостях. 

В вопросах безопасности вообще принято предполагать худшее и готовить план действий и защиту даже на такой случай. Будем считать, что злоумышленник нашел в веб-приложении лазейку, тем или иным способом радостно выгружает себе таблицу с именами и паролями пользователей и дальше уже распоряжается ими, как ему вздумается. В общем случае его дальнейшие действия могут быть крайне печальными.

Идея сразу оказывается не такой хорошей. Что делать? Здорово было бы хранить пароли в зашифрованном виде. Тогда, даже если их извлекут, восстановить не смогут или, по крайней мере, потратят на это слишком много времени. Здесь выбор встает между двумя ветками развития: шифровать пароли или хэшировать. Разработчики остановились на втором, и, в принципе, понятно, почему.

1. Трудоемкость. Шифрование занимает больше времени, а какое преобразование мы бы ни выбрали, его придется проделывать при каждой проверке пароля. Одним из требований к хэш-функциям же является быстрота выполнения.
1. Длина выходных значений. Результат шифрования имеет переменную длину, результат хэширования – всегда одинаковую, а хранить однородные по размеру данные в базе данных очень уж удобно. Не говоря уже о том, что длина пароля в зашифрованном виде будет давать некоторую информацию о длине исходного пароля. Одинаковая длина, правда, приводит к возможности возникновения коллизий, но об этом ниже.
1. Управление ключами. Для шифрования требуется ключ, который тоже где-то придется хранить и надеяться, что его никто не найдет. В любом случае, генерация и управление ключами это отдельная история (они не должны быть слабыми, их нужно регулярно менять и так далее).
1. Возможность коллизии. При шифровании выходные данные от различных входных даных всегда тоже будут различны. При хэшировании же это не всегда так. Постоянная длина хэша означает ограниченность множества выходных значений хэш-функции, что приводит к возможности коллизии. То есть, допустим, пользователь действительно заморочился и придумал себе по-настоящему классный длинный пароль, в котором есть и спецсимволы, и цифры, и буквы в нижнем и верхнем регистре. Злоумышленник вводит в поле пароля не менее классный пароль “admin”. Сервер для проверки и сравнения хэшей захэшировал его. Хэши совпали. Обидно.

Думаю вы поняли что вопрос хранения пароля не так прост. На эту тему есть множество вариантов решения, но я предлагаю устоявшийся вариант - bcrypt. Мы будем хешировать пароли с добавлением соли (случайной строки) и если юзер захочет войти в аккаунт то мы будем сравнивать хеши. Подробнее об хранении паролей можно прочитать [тут](//habr.com/ru/company/acribia/blog/413157/).

В общем давайте сделаем две функции внутри отдельного модуля.
Для это нам понадобится библиотека `bcrypt`

```
pip install bcrypt
```

Написание модуля элементарное, думаю комментировать его нет смысла

```python
from bcrypt import hashpw, checkpw, gensalt 

def hash_password(password):
    """
    Хеш функция для пароля
    Результат: хеш с солью
    """
    return hashpw(password.encode(), gensalt())

def equal_passwords(password, hashed_password):
    """
    Проверяет пароль и хеш
    Результат: True - пароли совпадают, False - не совпадают
    """
    return checkpw(password.encode(), hashed_password)
```
Все, далее просто будем пользоваться этими функциями чтобы не хранить пароли. Пароли от аккаунтов пользователей пока оставим в том виде в котором они сейчас есть, тк их хешировать нельзя, их нужно шифровать и на данный момент нам это не очень интересно.

> **Важно**
>
> Библиотека bcrypt обрезает строки длина которых больше 72 символа, поэтому мы должны ограничить пользователя от длины 72+ символов для пароля

## Auth



